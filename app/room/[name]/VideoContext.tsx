'use client'
import React, { createContext, useContext, useEffect, useState, useRef } from 'react'
import { LocalParticipant, RemoteParticipant, Track, Room } from 'livekit-client'

interface ParticipantState {
  id: string
  name: string
  isLocal: boolean
  hasCamera: boolean
  hasScreen: boolean
  hasAudio: boolean
  isSpeaking: boolean
  cameraElement: HTMLVideoElement | null
  screenElement: HTMLVideoElement | null
}

interface VideoContextType {
  participants: Map<string, ParticipantState>
  updateParticipant: (id: string, updates: Partial<ParticipantState>) => void
}

const VideoContext = createContext<VideoContextType | null>(null)

export function VideoProvider({ children, room }: { children: React.ReactNode, room: Room }) {
  const [participants, setParticipants] = useState<Map<string, ParticipantState>>(new Map())
  const trackRefs = useRef<Map<string, { camera?: any, screen?: any }>>(new Map())
  const videoElements = useRef<Map<string, { camera?: HTMLVideoElement, screen?: HTMLVideoElement }>>(new Map())

  const updateParticipant = (id: string, updates: Partial<ParticipantState>) => {
    setParticipants(prev => {
      const newMap = new Map(prev)
      const existing = newMap.get(id) || {
        id,
        name: id,
        isLocal: false,
        hasCamera: false,
        hasScreen: false,
        hasAudio: false,
        isSpeaking: false,
        cameraElement: null,
        screenElement: null
      }
      newMap.set(id, { ...existing, ...updates })
      return newMap
    })
  }

  const attachTrack = async (participant: LocalParticipant | RemoteParticipant, source: Track.Source) => {
    const publication = participant.getTrackPublication(source)
    const track = publication?.track
    const isLocal = participant instanceof LocalParticipant
    const trackType = source === Track.Source.Camera ? 'camera' : 'screen'
    
    console.log(`üîÑ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ ${trackType} –¥–ª—è ${participant.name}:`, {
      hasTrack: !!track,
      isLocal,
      isSubscribed: publication?.isSubscribed,
      trackState: track?.getState?.()
    })

    if (!track) {
      console.log(`‚ùå –ù–µ—Ç —Ç—Ä–µ–∫–∞ ${trackType} –¥–ª—è ${participant.name}`)
      updateParticipant(participant.identity, {
        [trackType === 'camera' ? 'hasCamera' : 'hasScreen']: false,
        [trackType === 'camera' ? 'cameraElement' : 'screenElement']: null
      })
      return
    }

    // –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞—ë–º –≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç
    const participantElements = videoElements.current.get(participant.identity) || {}
    let video = participantElements[trackType as keyof typeof participantElements]
    
    if (!video) {
      video = document.createElement('video')
      video.autoplay = true
      video.playsInline = true
      video.muted = isLocal
      participantElements[trackType as keyof typeof participantElements] = video
      videoElements.current.set(participant.identity, participantElements)
      console.log(`üì∫ –°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π –≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç ${trackType} –¥–ª—è ${participant.name}`)
    }

    // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
    if (video.srcObject) {
      const oldStream = video.srcObject as MediaStream
      oldStream.getTracks().forEach(track => track.stop())
      video.srcObject = null
    }

    try {
      let success = false

      if (isLocal) {
        console.log(`üè† –õ–æ–∫–∞–ª—å–Ω—ã–π —É—á–∞—Å—Ç–Ω–∏–∫ ${participant.name}, –ø—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ${trackType}`)
        
        // –°–ø–æ—Å–æ–± 1: –ü—Ä—è–º–æ–π MediaStream
        const directStream = (track as any).mediaStream
        if (directStream && !success) {
          video.srcObject = directStream
          success = true
          console.log(`‚úÖ –°–ø–æ—Å–æ–± 1: MediaStream –¥–ª—è ${trackType}`)
        }

        // –°–ø–æ—Å–æ–± 2: MediaStreamTrack
        if (!success) {
          const mediaStreamTrack = (track as any).mediaStreamTrack || (track as any)._mediaStreamTrack
          if (mediaStreamTrack) {
            const stream = new MediaStream([mediaStreamTrack])
            video.srcObject = stream
            success = true
            console.log(`‚úÖ –°–ø–æ—Å–æ–± 2: MediaStreamTrack –¥–ª—è ${trackType}`)
          }
        }

        // –°–ø–æ—Å–æ–± 3: –ü–æ–ª—É—á–∞–µ–º MediaStream –∏–∑ track
        if (!success && (track as any).getMediaStreamTrack) {
          try {
            const mediaStreamTrack = (track as any).getMediaStreamTrack()
            if (mediaStreamTrack) {
              const stream = new MediaStream([mediaStreamTrack])
              video.srcObject = stream
              success = true
              console.log(`‚úÖ –°–ø–æ—Å–æ–± 3: getMediaStreamTrack –¥–ª—è ${trackType}`)
            }
          } catch (e) {
            console.log(`‚ö†Ô∏è –°–ø–æ—Å–æ–± 3 –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: ${e}`)
          }
        }

        // –°–ø–æ—Å–æ–± 4: –ò—â–µ–º –≤ —Å–≤–æ–π—Å—Ç–≤–∞—Ö track
        if (!success) {
          const trackKeys = Object.keys(track)
          console.log(`üîç –°–≤–æ–π—Å—Ç–≤–∞ track:`, trackKeys)
          
          for (const key of trackKeys) {
            const value = (track as any)[key]
            if (value && value.constructor && value.constructor.name === 'MediaStreamTrack') {
              const stream = new MediaStream([value])
              video.srcObject = stream
              success = true
              console.log(`‚úÖ –°–ø–æ—Å–æ–± 4: –ù–∞–π–¥–µ–Ω MediaStreamTrack –≤ ${key}`)
              break
            }
          }
        }

        // –°–ø–æ—Å–æ–± 5: Fallback —á–µ—Ä–µ–∑ attach
        if (!success) {
          track.attach(video)
          success = true
          console.log(`‚úÖ –°–ø–æ—Å–æ–± 5: Fallback attach –¥–ª—è ${trackType}`)
        }

      } else {
        // –î–ª—è —É–¥–∞–ª—ë–Ω–Ω–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞
        track.attach(video)
        success = true
        console.log(`‚úÖ –£–¥–∞–ª—ë–Ω–Ω—ã–π ${trackType} –ø–æ–¥–∫–ª—é—á—ë–Ω —á–µ—Ä–µ–∑ attach`)
      }

      if (success) {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫
        const participantTracks = trackRefs.current.get(participant.identity) || {}
        participantTracks[trackType === 'camera' ? 'camera' : 'screen'] = track
        trackRefs.current.set(participant.identity, participantTracks)

        updateParticipant(participant.identity, {
          name: participant.name || participant.identity,
          isLocal,
          [trackType === 'camera' ? 'hasCamera' : 'hasScreen']: true,
          [trackType === 'camera' ? 'cameraElement' : 'screenElement']: video
        })

        console.log(`üéâ ${trackType} —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á—ë–Ω –¥–ª—è ${participant.name}`)
      }

    } catch (error) {
      console.error(`üí• –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ${trackType}:`, error)
      updateParticipant(participant.identity, {
        [trackType === 'camera' ? 'hasCamera' : 'hasScreen']: false,
        [trackType === 'camera' ? 'cameraElement' : 'screenElement']: null
      })
    }
  }

  const detachTrack = (participant: LocalParticipant | RemoteParticipant, source: Track.Source) => {
    const trackType = source === Track.Source.Camera ? 'camera' : 'screen'
    const participantTracks = trackRefs.current.get(participant.identity)
    const track = participantTracks?.[trackType === 'camera' ? 'camera' : 'screen']
    
    console.log(`üîå –û—Ç–∫–ª—é—á–µ–Ω–∏–µ ${trackType} –¥–ª—è ${participant.name}`)

    if (track && !(participant instanceof LocalParticipant)) {
      try {
        const participantElements = videoElements.current.get(participant.identity)
        const video = participantElements?.[trackType as keyof typeof participantElements]
        if (video) {
          track.detach(video)
        }
      } catch (error) {
        console.error(`–û—à–∏–±–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è ${trackType}:`, error)
      }
    }

    updateParticipant(participant.identity, {
      [trackType === 'camera' ? 'hasCamera' : 'hasScreen']: false,
      [trackType === 'camera' ? 'cameraElement' : 'screenElement']: null
    })
  }

  const updateAllTracks = () => {
    console.log('üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö —Ç—Ä–µ–∫–æ–≤')
    const allParticipants = [room.localParticipant, ...Array.from(room.remoteParticipants.values())]
    
    allParticipants.forEach(participant => {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–º–µ—Ä—É
      const cameraPublication = participant.getTrackPublication(Track.Source.Camera)
      const cameraTrack = cameraPublication?.track
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —ç–∫—Ä–∞–Ω
      const screenPublication = participant.getTrackPublication(Track.Source.ScreenShare)
      const screenTrack = screenPublication?.track
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—É–¥–∏–æ
      const audioPublication = participant.getTrackPublication(Track.Source.Microphone)
      const audioTrack = audioPublication?.track

      console.log(`üë§ ${participant.name}: –∫–∞–º–µ—Ä–∞=${!!cameraTrack}, —ç–∫—Ä–∞–Ω=${!!screenTrack}, –∞—É–¥–∏–æ=${!!audioTrack}`)

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–º–µ—Ä—É
      if (cameraTrack) {
        attachTrack(participant, Track.Source.Camera)
      } else {
        detachTrack(participant, Track.Source.Camera)
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω
      if (screenTrack) {
        attachTrack(participant, Track.Source.ScreenShare)
      } else {
        detachTrack(participant, Track.Source.ScreenShare)
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∞—É–¥–∏–æ
      updateParticipant(participant.identity, {
        hasAudio: !!audioTrack && !audioTrack.isMuted,
        isSpeaking: !!audioTrack && !audioTrack.isMuted
      })
    })
  }

  useEffect(() => {
    console.log('üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è VideoProvider')
    
    // –°–ª—É—à–∞–µ–º —Å–æ–±—ã—Ç–∏—è –∫–æ–º–Ω–∞—Ç—ã
    const events = [
      'trackPublished', 'trackUnpublished',
      'trackSubscribed', 'trackUnsubscribed', 
      'trackMuted', 'trackUnmuted',
      'localTrackPublished', 'localTrackUnpublished',
      'participantConnected', 'participantDisconnected'
    ]

    events.forEach(event => {
      room.on(event as any, (publication?: any) => {
        console.log(`üì° –°–æ–±—ã—Ç–∏–µ ${event}:`, publication?.source || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')
        setTimeout(updateAllTracks, 100) // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
      })
    })

    // –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
    setTimeout(updateAllTracks, 500)

    // –†–µ–≥—É–ª—è—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
    const interval = setInterval(updateAllTracks, 1000)

    return () => {
      console.log('üõë –û—á–∏—Å—Ç–∫–∞ VideoProvider')
      events.forEach(event => {
        room.off(event as any, updateAllTracks)
      })
      clearInterval(interval)
      
      // –û—á–∏—â–∞–µ–º –≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç—ã
      videoElements.current.forEach((elements) => {
        Object.values(elements).forEach(video => {
          if (video && video.srcObject) {
            const stream = video.srcObject as MediaStream
            stream.getTracks().forEach(track => track.stop())
            video.srcObject = null
          }
        })
      })
      videoElements.current.clear()
    }
  }, [room])

  return (
    <VideoContext.Provider value={{ participants, updateParticipant }}>
      {children}
    </VideoContext.Provider>
  )
}

export function useVideo() {
  const context = useContext(VideoContext)
  if (!context) {
    throw new Error('useVideo must be used within VideoProvider')
  }
  return context
}
